// Generated by CoffeeScript 1.6.3

/*
    A safe wrapper around the request to hide access to query, params and body.
    This allows us to sanitize those fields when requested.
 */

(function() {
  var RequestParser, body, co, multipart, sanitizer, validator,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  validator = require('validator');

  sanitizer = require('sanitizer');

  co = require('co');

  body = require('co-body');

  multipart = require('co-multipart');

  RequestParser = (function() {
    function RequestParser(ctx, typeUtils) {
      this.ctx = ctx;
      this.typeUtils = typeUtils;
      this.parseSimpleType = __bind(this.parseSimpleType, this);
      this.setCustomType = __bind(this.setCustomType, this);
      this.setArray = __bind(this.setArray, this);
      this.setSimpleType = __bind(this.setSimpleType, this);
      this.setField = __bind(this.setField, this);
      this.map_impl = __bind(this.map_impl, this);
      this.map = __bind(this.map, this);
      this.files = __bind(this.files, this);
      this.body = __bind(this.body, this);
    }

    RequestParser.prototype.body = function*(name, def) {
      var value;
      if (def == null) {
        def = {
          type: 'string'
        };
      }
      if (!this.initted) {
        this.rawBody = yield body(this.ctx);
        this.initted = true;
      }
      if (typeof def === 'string') {
        def = {
          type: def
        };
      }
      value = this.rawBody[name];
      if (value) {
        return this.parseSimpleType(value, name, def);
      }
    };

    RequestParser.prototype.files = function*() {
      return (yield* multipart(this.ctx)).files;
    };

    RequestParser.prototype.map = function*(target, whitelist, options, parents) {
      var f;
      if (options == null) {
        options = {
          overwrite: true
        };
      }
      if (parents == null) {
        parents = [];
      }
      whitelist = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = whitelist.length; _i < _len; _i++) {
          f = whitelist[_i];
          _results.push(f.split('_'));
        }
        return _results;
      })();
      return yield* this.map_impl(target, whitelist, options, parents);
    };

    RequestParser.prototype.map_impl = function*(target, whitelist, options, parents) {
      var a, changed, def, fieldName, fieldWhiteList, typeDef, _ref;
      typeDef = yield* target.getTypeDefinition();
      _ref = typeDef.schema.properties;
      for (fieldName in _ref) {
        def = _ref[fieldName];
        fieldWhiteList = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = whitelist.length; _i < _len; _i++) {
            a = whitelist[_i];
            if (a[0] === fieldName) {
              _results.push(a);
            }
          }
          return _results;
        })();
        if (yield* this.setField(target, fieldName, def, typeDef, fieldWhiteList, options, parents)) {
          changed = true;
        }
      }
      return changed;
    };

    RequestParser.prototype.setField = function*(obj, fieldName, def, typeDef, whitelist, options, parents) {
      var _ref;
      if (this.typeUtils.isPrimitiveType(def.type)) {
        if (def.type !== 'array') {
          if (((_ref = whitelist[0]) != null ? _ref[0] : void 0) === fieldName) {
            return yield* this.setSimpleType(obj, fieldName, def, typeDef, whitelist, options, parents);
          }
        } else {
          return yield* this.setArray(obj, fieldName, def, typeDef, whitelist, options, parents);
        }
      } else {
        return yield* this.setCustomType(obj, fieldName, def, typeDef, whitelist, options, parents);
      }
    };

    RequestParser.prototype.setSimpleType = function*(obj, fieldName, def, typeDef, whitelist, options, parents) {
      var changed, formField, result, val;
      formField = parents.concat(fieldName).join('_');
      val = yield* this.body(formField);
      if (val) {
        result = this.parseSimpleType(val, fieldName, def, typeDef);
        if (!(obj instanceof Array)) {
          if (options.overwrite) {
            obj[fieldName] = result;
          } else {
            if (obj[fieldName] == null) {
              obj[fieldName] = result;
            }
          }
          changed = true;
        } else {
          obj.push(result);
          changed = true;
        }
      }
      return changed;
    };

    RequestParser.prototype.setArray = function*(obj, fieldName, def, typeDef, whitelist, options, parents) {
      var changed, counter, formField, i, items, newArray, val, _i, _len, _ref, _ref1;
      if (typeDef != null ? (_ref = typeDef.mapping) != null ? _ref[fieldName] : void 0 : void 0) {
        if (def.items.type !== 'array') {
          if (whitelist.indexOf(fieldName) !== -1) {
            formField = parents.concat(fieldName).join('_');
            val = yield* this.body(formField);
            items = val.split(',');
            for (_i = 0, _len = items.length; _i < _len; _i++) {
              i = items[_i];
              obj[fieldName].push(this.parseSimpleType(val, "" + fieldName + "[]", def.items, def));
              changed = true;
            }
          }
        } else {
          throw new Error("Cannot map array of arrays");
        }
      } else {
        parents.push(fieldName);
        counter = 1;
        newArray = (_ref1 = obj[fieldName]) != null ? _ref1 : [];
        while (true) {
          if (yield* this.setField(newArray, counter, def.items, def, whitelist, options, parents)) {
            counter++;
            if (obj[fieldName] == null) {
              obj[fieldName] = newArray;
            }
            changed = true;
          } else {
            break;
          }
        }
        parents.pop();
      }
      return changed;
    };

    RequestParser.prototype.setCustomType = function*(obj, fieldName, def, typeDef, whitelist, options, parents) {
      var a, changed, newObj, _ref;
      whitelist = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = whitelist.length; _i < _len; _i++) {
          a = whitelist[_i];
          _results.push(a.slice(1));
        }
        return _results;
      })();
      parents.push(fieldName);
      if ((_ref = def.typeDefinition) != null ? _ref.ctor : void 0) {
        newObj = new def.typeDefinition.ctor();
        changed = yield* this.map_impl(newObj, whitelist, options, parents);
        if (changed) {
          if (!(obj instanceof Array)) {
            obj[fieldName] = newObj;
          } else {
            obj.push(newObj);
          }
        }
      }
      parents.pop();
      return changed;
    };

    RequestParser.prototype.parseSimpleType = function(val, fieldName, def, typeDef) {
      var _ref;
      if (val) {
        switch (def.type) {
          case 'integer':
            return parseInt(val);
          case 'number':
            return parseFloat(val);
          case 'string':
            if ((typeDef != null ? (_ref = typeDef.htmlFields) != null ? _ref.indexOf(fieldName) : void 0 : void 0) !== -1) {
              return sanitizer.sanitize(sanitizer.unescapeEntities(val));
            } else {
              return sanitizer.escape(val);
            }
            break;
          case 'boolean':
            return val === "true";
          default:
            throw new Error("" + def.type + " " + fieldName + " is not a primitive type or is an array. Cannot parse.");
        }
      }
    };

    return RequestParser;

  })();

  module.exports = RequestParser;

}).call(this);
